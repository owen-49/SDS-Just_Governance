

# 一、400/422/401/403/404/405 （最常见的客户端请求错误）

## 400 Bad Request（请求格式/语义不对，但不是字段级）

**什么时候用**

- JSON 语法错误（HTTP请求body 不是合法 JSON）。
- 参数组合不合法（例如 `start > end`、互斥参数同时出现），但**不是**某个字段类型/格式错误。
- 自定义签名/回调的“校验字符串不通过”。

**FastAPI怎么抛**

```python
from fastapi import HTTPException
raise HTTPException(status_code=400, detail="malformed_json")
```

**统一响应（你现在的映射）**

- HTTP→biz：400 → `CODE_VALIDATION_ERROR=2001`（你在 `_map_http_to_biz` 里已这么做）
- 建议：`message="bad_request"` 或保留 `exc.detail` 为字符串时直透
- `data`：可选放 `{ "reason": "malformed_json" }`

**前端处理**

- 不跳页；toast/对话框提示“请求不正确，请重试”，或根据 `code` 映射更友好文案。

**注意**

- **字段级错误不要用 400**，而用 422（见下）。

------



## 422 Unprocessable Entity（字段级校验失败）

**什么时候用**

- Pydantic/FastAPI 入参校验（body/query/path）失败：类型、格式、范围、必填、枚举越界等。

**FastAPI怎么抛**

- 框架自动抛 `RequestValidationError`；别自己抛 422。

**统一响应**

```python
http_status = 422
code = CODE_VALIDATION_ERROR  # 2001
message = "validation_error"
data = {"errors": exc.errors()}  # 标准化列表：包含 loc/msg/type 等
```

> 如需“用户可读”，可在 handler 里把 `exc.errors()` 映射为 `{field, msg}` 形式。

**前端处理**

- 按 `data.errors` 渲染到具体表单字段旁（红字/气泡），无需 toast。

**注意**

- **字段级错误只在 422 返回**；不要混用 400。

##### 400 vs 422 的区别

- **400 Bad Request**
   意思是：请求报文本身就是**畸形的 / 无法被服务器理解**。
   👉 例子：
  - JSON 语法错误（花括号不闭合）
  - Content-Type 不是 `application/json`，但却传了 JSON
  - 查询参数里 `limit=abc`，但服务器期望 int（有些框架直接给 400）
- **422 Unprocessable Entity**
   意思是：请求报文**语法正确，可以解析**，但**语义有问题**，导致无法处理。
   👉 例子：
  - JSON 格式正确，但字段类型不对（`age: "abc"`）
  - 缺少必填字段（`name` 缺失）
  - 嵌套字段不符合约束（`email: "not-an-email"`）

📖 根据 **RFC 7231/4918**：

- `400` 更偏向**格式错误**。

- `422` 更偏向**数据不合规**。

  

## 401 Unauthorized（未认证/凭证失效）

**什么时候用**

- 没带 `Authorization`，或 token 过期/无效。

**FastAPI怎么抛**

```python
raise HTTPException(
    status_code=401,
    detail="unauthenticated",
    headers={"WWW-Authenticate": "Bearer"}
)
```

**统一响应**

- 401 → `CODE_UNAUTHORIZED=1001`
- `message`：`"unauthenticated"` / `"token_expired"`
- `data`：可选 `{ "resend_available": true }` 等指引信息

**前端处理**

- **自动跳登录/刷新令牌**；失败则重登。UI 显示“登录已过期”。

**注意**

- **记得带 `WWW-Authenticate`；可区分 `token_invalid` / `token_expired` 用不同业务码。**

------



## 403 Forbidden（已登录但无权限）

**什么时候用**

- 角色/权限不足、功能未开启、配额/策略限制（非限流）。

**FastAPI怎么抛**

```python
raise HTTPException(status_code=403, detail="forbidden")
```

**统一响应**

- 403 → `CODE_FORBIDDEN=1002`
- `message`：`"forbidden"`
- `data`：可选 `{ "required_role": "admin" }`

**前端处理**

- 展示“无权限”页/弹窗；可给“申请权限/切换账号”入口。

**注意**

- 和 401 分清：401 是没认证；403 是已认证但无权。

------



## 404 Not Found（路由或资源不存在）

**什么时候用**

- 访问了不存在的路由。
- 资源 ID 不存在（**或出于安全，不想暴露存在与否**）。

**FastAPI怎么抛**

```python
raise HTTPException(status_code=404, detail="not_found")
```

**统一响应**

- 404 → `CODE_NOT_FOUND=3001`
- `message`：`"not_found"`
- `data`：可选 `{ "resource": "user" }`

**前端处理**

- 空态页/返回上一页/跳首页。

**注意**

- 不泄露敏感存在性（“用户名不存在/存在但无权”都可用 404）。

------



## 405 Method Not Allowed（方法不被允许）

**什么时候用**

- 对只支持 GET 的路由发了 POST 等。

**FastAPI怎么抛**

- 框架会自动返回 405，并附 `Allow: GET, HEAD`。

**统一响应**

- 目前未在映射表中列出 405，但在 `_map_http_to_biz` 里有“其它 4xx 兜底 → 2001”，因此：
  - 405 → `CODE_VALIDATION_ERROR=2001`
  - `message`：`"method_not_allowed"`
  - `data`：可选 `{ "allow": ["GET","HEAD"] }`（可从响应头读）

**前端处理**

- 一般只做兜底提示；开发阶段容易暴露出来，线上较少见。

**注意**

- 若想更细，可新增业务码 `2002 method_not_allowed`；否则沿用 2001 也行。

------

## 设计与约定（跨所有状态码）

- **HTTP（协议语义）**：让客户端知道该走的**全局动作**（401 登录、403 权限、429 冷却、404 空态）。
- **业务码 `code`（领域语义）**：让前端进一步**细分处理/文案**（如 409 里区分 email 已存在 vs 版本冲突）。
  - 你的当前最小集：`1001/1002/2001/3001/4001/8001/9001` 足够起步；后续可细分（仍落在相同 HTTP 下）。
- **message（短标签）**：稳定、无敏感的**错误标签**（如 `"validation_error"`, `"forbidden"`, `"conflict"`），给日志/兜底用；**不直出内部异常文本**。
- **data**：
  - `422`：`data.errors=[{field,msg,...}]`（用于表单逐项展示）
  - 其它：按需给**安全**的上下文（如 `detail/allow/current_state`），避免泄露。
- **响应头**：
  - 401：`WWW-Authenticate: Bearer`
  - 405：`Allow: GET, POST, ...`
  - 429/503：可选 `Retry-After`
- **日志**：所有错误打结构化日志：`request_id/path/method/http_status/code/message`（堆栈仅在 5xx）。

------

## 一张对照表（可贴文档）

| HTTP | 语义                 | 典型场景                  | 业务码（建议）        | 前端动作    |
| ---- | -------------------- | ------------------------- | --------------------- | ----------- |
| 400  | 请求不对（非字段级） | JSON 语法坏、参数组合非法 | 2001 或新增 2002      | 普通提示    |
| 401  | 未认证/凭证失效      | 缺/失效 token             | 1001（细分可加 1003） | 跳登录/刷新 |
| 403  | 无权限               | 角色/策略限制             | 1002（可细分 110x）   | 无权限页    |
| 404  | 不存在/不暴露存在性  | 路由/资源不存在           | 3001                  | 空态/返回   |
| 405  | 方法不允许           | GET 路由被 POST           | 2001（或新增 2002）   | 普通提示    |
| 422  | **字段级校验失败**   | Pydantic 校验失败         | 2001                  | 渲染表单    |

> 记住“**HTTP 定大类、code 定细因**；字段错只走 422；敏感信息只进日志”。这样前后端协作会非常顺畅。





# 二、200/201/202/204（四类成功响应）

## 200 OK（标准成功）

- **语义**：请求成功并返回**资源表示**（JSON 等）。

- **何时用**：常规查询、更新后返回当前资源、动作成功且有数据。

- **FastAPI**：

  ```python
  @app.get("/users/{id}", status_code=200)
  def get_user(id: UUID): ...
  ```

- **前端**：正常渲染 `data`；可配合 `ETag/Last-Modified` 做缓存（配 304）。

## 201 Created（已创建）

- **语义**：创建了**新资源**；应返回 `Location` 指向新资源 URL（最好连资源体一起返）。

- **何时用**：`POST /users` 新建、`PUT` 首次创建（幂等）也可用。

- **FastAPI**：

  ```python
  from fastapi import Response
  @app.post("/users", status_code=201)
  def create_user(..., response: Response):
      uid = svc.create(...)
      response.headers["Location"] = f"/api/v1/users/{uid}"
      return ApiResponse(data={"user_id": str(uid)}).model_dump()
  ```

- **前端**：优先跳转 `Location` 或使用返回体里的 `id` 进入详情。

## 202 Accepted（已接受，异步处理）

- **语义**：请求已接收，**后台异步**处理中；当前没有最终结果。

- **何时用**：导入、生成报告、训练任务、视频转码等异步作业。

- **惯例**：返回**跟踪地址**或任务 id。

- **FastAPI**：

  ```python
  @app.post("/reports", status_code=202)
  def gen_report(..., response: Response):
      task_id = tasks.enqueue(...)
      response.headers["Location"] = f"/api/v1/tasks/{task_id}"
      return ApiResponse(data={"task_id": task_id}).model_dump()
  ```

- **前端**：跳转/轮询 `Location` 或 `/tasks/{id}`，显示进度/重试。

## 204 No Content（成功且无响应体）

- **语义**：成功，但**没有响应体**（必须真的空）。

- **何时用**：`DELETE` 成功、`PATCH/PUT` 成功但不回资源、幂等操作无变化。

- **FastAPI**：

  ```python
  from fastapi import Response
  @app.delete("/users/{id}", status_code=204)
  def remove_user(id: UUID):
      svc.delete(id)
      return Response(status_code=204)  # 不要返回 JSON/正文
  ```

- **前端**：不解析 body；更新列表/返回上一页。

> 小抄：**200**=有内容；**201**=新建+`Location`；**202**=排队中+任务引用；**204**=成功但无内容。



# 三、HTTP响应码、业务码的设计与映射

---

## 1. 一个 HTTP → 多个业务码，正常且**推荐**

- **HTTP 表达协议/传输层语义**（鉴权、存在、限流…）。
- **业务码表达领域细因**（邮箱已存在、版本冲突、功能关闭…）。
- 典型是**多对一**：例如都用 409，但业务码可细分：
  - `4001 conflict`（通用冲突）
  - `4002 email_exists`
  - `4003 version_conflict`
  - `4004 state_invalid`

> 前端：先按 **HTTP** 做全局动作（401/403/404/429），再用 **code** 决定具体文案与交互。

---



## 2) 后端该记录“http→code”还是“code→http”的映射表？

两张表各司其职，**一起用**效果最好：

- **`HTTP → 默认业务码`**（处理 `HTTPException` 等框架抛出的错误）
   你已有 `_HTTP_TO_BIZ`：401→1001，403→1002，404→3001，422→2001，…
   用于**没有业务细因**时的**兜底映射**。
- **`CODE → HTTP`**（你**主动**抛 `BizError` 时）
   `BizError` 已经同时带 `http_status` 和 `code`，其实不需要映射；
   如果你想校验一致性，可在常量区维护一个 `CODE_TO_HTTP = {4002: 409, ...}` 用于测试/审计。

> 扩展业务码时，无需改 `HTTP→code` 表（它只是默认值）；**在业务里抛 `BizError` 指定具体 code + http 即可。**



## 3) 业务码用字符串常量还是整数？

**两种都可行**，关键是团队一致。

| 形式     | 示例                      | 优点                                                        | 缺点                                    | 适用                             |
| -------- | ------------------------- | ----------------------------------------------------------- | --------------------------------------- | -------------------------------- |
| 整数     | `4002`                    | 传输小、好分段（1xxx/2xxx…）、前端易做 switch、日志统计方便 | 语义需查表                              | 当前设计（已在文档与代码中使用） |
| 字符串键 | `"conflict.email_exists"` | 读起来自解释、易 i18n、无需查表                             | 前端要统一大小写/命名；日志统计要再分组 | 新项目或强 i18n/规则很多         |

**折中推荐（与现状最兼容）**：

- **保留整数 `code`**（不破坏现有前后端、文档、监控）。
- **把“稳定的语义标签”放在 `message`**（如 `"validation_error"`, `"email_exists"`）。
   目前已经这么做了：`message` 不是用户文案，是稳定键；真正给用户看的——前端走 `code→文案表` 或 `data.errors`即可。

### 写成 Enum，防止乱用

```python
from enum import IntEnum
class BizCode(IntEnum):
    OK = 0
    UNAUTHORIZED = 1001
    FORBIDDEN = 1002
    VALIDATION_ERROR = 2001
    NOT_FOUND = 3001
    CONFLICT = 4001
    RATE_LIMITED = 8001
    INTERNAL_ERROR = 9001
```

使用时：

```python
ApiResponse(code=BizCode.CONFLICT, message="email_exists", ...)
```



## 4) 扩展业务码的“安全姿势”

- 约定**段位**：`1xxx` 鉴权、`2xxx` 校验、`3xxx` 资源、`4xxx` 冲突/状态、`5xxx` 外部依赖、`8xxx` 流控、`9xxx` 系统。
- **一码一义**，发布后尽量不复用/不改语义。
- 文档为每个 `code` 写清：**对应 HTTP、含义、前端建议动作、用户可见文案（或 i18n key）**。
- 在业务里**显式抛 `BizError(http_status, code, message[, data])`**，避免靠默认映射吃语义。

------



# 四、业务码（business code）

## 1. 业务码的通用规范

###  1) 目标与职责

- **HTTP 码：** 表达协议/传输层语义（认证、权限、存在、限流…）→ 前端“全局动作”的依据。
- **业务码：** 表达**领域层细因**（邮箱已存在、版本冲突、状态不允许…）→ 前端“精细交互/文案”的依据。
- 关系：**一对多**（一个 HTTP 码下可以有多个业务码），**不要追求一一对应**。

###  2) 编码风格

- **整数分段**（与当前工程一致）：
  - **`0` 成功**
  - **`1xxx` 鉴权/认证**
  - **`2xxx` 请求/校验/协议**
  - **`3xxx` 资源/存在性**
  - **`4xxx` 业务冲突/状态非法**
  - `5xxx` 外部依赖/下游
  - `8xxx` 流控/配额/节流
  - `9xxx` 系统/未知
- **稳定短标签**（放到 `message`）：如 `"validation_error"`, `"email_exists"`, `"version_conflict"`（给日志/兜底用，**不是**直接面向用户的句子）
- 可选：再加一个 `error_key`（字符串键），用于 i18n；但现在用“整数 code + 短标签 message”已经足够。

### 3) 响应载荷约定

- **成功**：`{ code:0, message:"ok", data, request_id }`
- **失败**：`{ code:非0, message:"短标签", data, request_id }`
  - **字段级错误**：`422` 下 `data.errors = [{field, msg}]`
  - **限流**：`429` 下 响应头 `Retry-After`
  - **冲突**：`409` 下可携带 `data.field / current_state / conflict_with`
  - **千万别泄漏**内部异常/SQL/堆栈到响应体（只进日志）

### 4) 前端协作规则（强烈建议）

- **自动化处理优先级**：HTTP（401/403/429/404…）→ `code`（细分交互）→ `data.errors`（字段渲染）
- **用户可见文案**：非字段错误用 `code → 文案表（i18n）`；字段错误用 `data.errors.msg`
- `message` 只作稳定标签或兜底，不直接展示敏感细节

------



## 2. 常见 HTTP → 多业务码映射

> 说明：这是“**默认/兜底映射**”思路 + “**业务里显式抛 BizError**”的组合。
>
> - 框架抛 `HTTPException` 时，用下面默认映射；
> - 你在业务里抛 `BizError(http_status, code, message[, data])` 时，**直接指定更细的 code**。

| HTTP    | 语义                      | 建议业务码（示例，可按需取舍扩展）                           |
| ------- | ------------------------- | ------------------------------------------------------------ |
| **200** | OK                        | `0 ok`                                                       |
| **201** | Created                   | `0 ok`（语义靠 HTTP，必要时在 `data` 返回新 id）             |
| **202** | Accepted（异步）          | `0 ok`（在 `data` 返回 `task_id`，或 `Location` 头）         |
| **204** | No Content                | `0 ok`（无体）                                               |
| **400** | Bad Request（非字段级）   | `2002 malformed_json`、`2003 invalid_request`、`2007 unsupported_param_combo` |
| **401** | 未认证/凭证失效           | `1001 unauthenticated`、`1003 token_expired`、`1004 token_invalid` |
| **403** | 无权限                    | `1002 forbidden`、`1101 forbidden_role`、`1102 feature_flag_off`、`1103 quota_exceeded` |
| **404** | 不存在/不暴露存在性       | `3001 not_found`、`3003 private_resource`                    |
| **405** | 方法不允许                | `2008 method_not_allowed`                                    |
| **406** | 不可接受（内容协商失败）  | `2004 not_acceptable`                                        |
| **409** | 冲突/状态非法             | `4001 conflict`、`4002 email_exists`、`4003 version_conflict`、`4004 state_invalid`、`4005 already_done` |
| **410** | 已永久删除                | `3002 gone`                                                  |
| **412** | 先决条件失败（ETag/If-*） | `4006 precondition_failed`（可在 `data` 回 `current_etag`）  |
| **413** | 体积过大                  | `2006 payload_too_large`（在 `data` 回 `max_mb`）            |
| **415** | 媒体类型不支持            | `2005 unsupported_media_type`（在 `data` 回 `supported` 列表） |
| **422** | 字段级校验失败            | `2001 validation_error`（`data.errors=[{field,msg}]`）       |
| **429** | 频率限制                  | `8001 rate_limited`（`data.retry_after` 或头 `Retry-After`） |
| **500** | 内部错误                  | `9001 internal_error`                                        |
| **502** | 下游错误                  | `5001 upstream_error`                                        |
| **503** | 服务不可用/维护           | `5002 service_unavailable`（可带 `Retry-After`）             |
| **504** | 下游超时                  | `5003 upstream_timeout`                                      |

> 项目已有最小集：`0/1001/1002/2001/3001/4001/8001/9001`。
>  上表是在此基础上**可按需增加**的子码（无需一次全加，遇到真实场景再补最稳妥）。

------

## 3. 实现建议

### 1) 常量与枚举

- 使用 **IntEnum** 管理 code，避免魔法数字乱飞：

  ```python
  class BizCode(IntEnum):
      OK = 0
      UNAUTHENTICATED = 1001
      FORBIDDEN = 1002
      VALIDATION_ERROR = 2001
      MALFORMED_JSON = 2002
      NOT_FOUND = 3001
      CONFLICT = 4001
      EMAIL_EXISTS = 4002
      VERSION_CONFLICT = 4003
      RATE_LIMITED = 8001
      INTERNAL_ERROR = 9001
      # ...按需扩展
  ```

- `message` 用对应的稳定短标签（字符串），如 `"email_exists"`。

### 2) 映射表

- **HTTP→默认 code**（框架异常兜底）：保留你已有 `_HTTP_TO_BIZ`，按需补 406/410/412/413/415。
- **BizError** 场景**不查表**：由调用处显式给 `http_status + code`。
- 做个 `CODE_TO_HTTP` 只用于**单测校验**一致性，避免某个 code 错配 HTTP。

### 3) 文档模板（每个 code 一条）

- `http_status:`
- `code:`
- `message:`（短标签）
- `meaning:`（一句话）
- `frontend_action:`（跳登录/渲染表单/倒计时…）
- `data:`（结构示例）
- `example:`（完整响应示例）

### 4) 前端用法固定下来

- 先看 **HTTP** 做全局动作；
- 若 `code==2001 && data.errors` → 表单渲染；
- 其余走 **`code→i18n 文案表`**；`message` 仅兜底/开发态；
- Always 显示“更多信息/客服”里带上 `request_id`。

---



# 五、301/302/304（重定向类响应码）

## 301 Moved Permanently（永久重定向）

**语义**
 资源永久搬家了，以后都去新地址。客户端和中间层（搜索引擎、CDN、浏览器）会**长期缓存**这个重定向。

**在项目里何时用**

- 域名/路径永久调整：如 `http://` → `https://`、`www` → 裸域、老文档 `/v1/docs` → 新 `/docs`。
- 老 API **不再提供**，但你决定“长期指到新地址”。（一般来说，API 升级还是更偏向返回 410/新版本并行，301 用得少）

**FastAPI 写法**

```py
from fastapi.responses import RedirectResponse

@app.get("/old-path")
def moved():
    return RedirectResponse(url="/new-path", status_code=301)
```

**头部建议**

- 必带 `Location: /new-path`
- 建议带 `Cache-Control: public, max-age=86400`（或让网关配）

**与统一响应壳/异常器的关系**
 301 是**正常响应**，**不要**走统一 JSON 壳；也**不会**经过你的全局异常处理器。

**前端行为**
 浏览器/`fetch` 默认会跟随重定向（常常直接到达新地址）；如果希望前端拿到 `Location` 自行处理，`fetch` 需要 `redirect: "manual"`。

> 小提示：API 场景下，301 用得很少；大多用于**静态站点/页面**或**网关层**。

------



## 302 Found（临时重定向）

**语义**
 资源**暂时**在别处；以后可能还会回到原地址。客户端不应长期缓存这个重定向。

**在项目里何时用（很常见）**

- 邮箱验证/第三方登录 **回调**：后端处理完 token/状态后，**302 跳转**回前端页面（如 `/auth/callback?ok=1`）。
- 表单“提交后跳详情页”（严格来讲应用 303/307/308，见下面提醒）。

**FastAPI 写法**

```py
from fastapi.responses import RedirectResponse

@app.get("/api/v1/auth/verify-email")
def verify_email(token: str):
    # 校验 token ...
    return RedirectResponse(url="/verified-success", status_code=302)
```

**头部**

- 必带 `Location`
   -（可选）短期缓存：`Cache-Control: no-store`（通常无需缓存）

**与统一响应壳/异常器**
 一样，302 是**正常响应**，**不包 JSON**、不经异常处理器。

**前端行为**

- 浏览器会自动跳；SPA 为了可控，可以在 API 返回 200 + JSON（含 `redirect_to`）由前端自己跳。**二选一**，别同时做。

**重要提醒：302 的方法语义**
 历史上部分客户端会把 **POST→GET**（有歧义）。
 更安全的选择：

- **303 See Other**：明确“POST 完后去 GET 某地址”（PRG 模式）。
- **307/308**：严格**保留原方法**（POST 仍 POST）。
   虽然你只问 302，但在“登录/回调/表单提交”这些点，**更推荐 303/307/308**，避免方法被改变。

------



## 304 Not Modified（未修改，走缓存）

**语义**
 客户端带了条件头（`If-None-Match` / `If-Modified-Since`），服务器确认**资源没变**，因此**不返回响应体**（省流量/更快）。

**在你的项目里何时用**

- GET 接口**支持缓存**：列表/详情等读请求，返回 `ETag` 或 `Last-Modified`，下次客户端带条件头，命中就给 304。

**FastAPI 正确写法（重点！）**

- **命中缓存**：**返回空体**的 304（不包 JSON！）
- **未命中**：返回 200 + 你的统一 JSON 壳，并附相同缓存头

```python
from fastapi import Request, Response
from fastapi.responses import JSONResponse
from app.schemas.api_response import ApiResponse  # 你的响应壳

@app.get("/api/v1/items/{item_id}")
def get_item(item_id: str, request: Request):
    # 1) 生成/读取当前资源的 ETag（或 Last-Modified）
    etag = compute_item_etag(item_id)  # 自己实现，比如内容 hash / updated_at 指纹

    # 2) 命中客户端条件请求 → 返回 304（空体）
    if request.headers.get("if-none-match") == etag:
        return Response(status_code=304, headers={"ETag": etag, "Cache-Control": "max-age=60"})

    # 3) 未命中 → 返回 200 + JSON 壳 + 相同 ETag
    payload = ApiResponse(data={"item_id": item_id, "name": "..." }).model_dump()
    return JSONResponse(
        status_code=200,
        content=payload,
        headers={"ETag": etag, "Cache-Control": "max-age=60"}
    )
```

**为什么 304 不能包统一 JSON？**
 HTTP 规范规定 304 **不应**有响应体。客户端通常也**不会读 body**。因此你的统一壳**只在 200** 那支返回。

**前端行为**

- 浏览器/`fetch` 命中 304 时，一般直接使用本地缓存的上一次 200 响应体。
- 手写客户端要处理条件请求头，并在 304 时使用本地缓存副本。

**配套头部**

- ETag 方案：`ETag` + 请求 `If-None-Match`
- 时间戳方案：`Last-Modified (RFC1123)` + 请求 `If-Modified-Since`
- 可加 `Cache-Control: max-age=...`、`Vary`（如 `Vary: Authorization, Accept-Encoding`）

------

## 和你现有“统一响应 + 异常处理器”的边界总结

- **3xx（301/302/304）都是“正常响应”**：不走异常处理器，也**不包统一 JSON 壳**（尤其 304 必须空体；301/302 客户端多半也不会看 body）。
- 需要返回 JSON 的“跳转指引”，就**不要用 3xx**，直接 `200` + `data.redirect_to` 让前端自己跳；两种风格二选一，别混。
- **缓存（304）**：200 分支用你的统一壳，304 分支空体 + 缓存头，前端/浏览器自动对齐。

------

## 可直接落地的小规范

1. **重定向**
   - 页面/回调：用 **302/303/307/308** + `Location`，不包 JSON。
   - API 内跳转建议：**200 + data.redirect_to**（前端自行处理）。
2. **永久变更**
   - 链接/静态资源：**301**（长期缓存）。
   - API 升级：优先并行新版本或 410；谨慎用 301。
3. **缓存**
   - GET 支持 `ETag`/`Last-Modified`；命中则 **304（空体）**，未命中 **200 + JSON 壳**，两支都带相同缓存头。
4. **日志**
   - 3xx/304 也要打结构化日志（含 `request_id/status/location/etag`），便于观察命中率与跳转链路。



# 六、500/502/503/504 （服务器内部错误处理）

> 所谓服务器内部错误，说白了就是后端代码自己的逻辑或运行出了问题，责任不在于前端或用户。
>
> 比如程序本身有bug，或者服务器运行时出现了某种问题，或者任何无法定性或者原因不明确的错误，均可归为服务器内部错误，HTTP响应码均可设置为500。
>
> 502 503 504是更为明确、更为细致的服务器错误表述，可以不用管。

### 500 Internal Server Error（服务内部错误，最常用，偷懒办法）

- **语义**：**未捕获异常/代码 bug/不可预期错误。**
- **抛法**：不用手动抛。**全局异常处理器的兜底 `Exception` → `500 + code=9001 + message="internal_error"`。**
- **返回**：**绝不**透出堆栈/SQL/内部细节，只给 `request_id`；细节进日志。
- **前端**：统一“系统繁忙，请稍后再试”；保留“反馈问题”里显示 `request_id`。

------

### *502 Bad Gateway（网关到下游失败）

- **语义**：API 网关或你的服务作为代理，调用**下游**返回错误（或不可达）。

- **抛法**：在“调用下游”的边界层捕获异常，翻译：

  ```
  raise BizError(502, 5001, "upstream_error")
  ```

- **前端**：提示临时故障/可重试；必要时退化展示。

------

### *503 Service Unavailable（服务不可用/维护/压力保护）

- **语义**：服务不可用、维护中、熔断/过载保护。

- **返回**：可带 `Retry-After`（秒或日期），或在 `data.retry_after` 返回。

- **抛法**：

  ```
  raise BizError(503, 5002, "service_unavailable", data={"retry_after": 30})
  ```

- **前端**：倒计时重试/展示维护页。

------

### *504 Gateway Timeout（下游超时/处理超时）

- **语义**：作为代理或网关等待下游超时；或你的处理在上游网关超时被切。

- **抛法**：

  ```
  raise BizError(504, 5003, "upstream_timeout")
  ```

- **前端**：提示网络/服务超时；引导重试/降级。

------

### 小对照（5xx 建议业务码）

| HTTP | 业务码（示例） | message（标签）     | 用途           |
| ---- | -------------- | ------------------- | -------------- |
| 500  | 9001           | internal_error      | 未知异常兜底   |
| 502  | 5001           | upstream_error      | 下游返回错误   |
| 503  | 5002           | service_unavailable | 维护/熔断/过载 |
| 504  | 5003           | upstream_timeout    | 下游超时       |

> 5xx 都属“技术/系统”类：**不要**把内部细节给用户；**要**把 `request_id` + 结构化日志打全。



# 七、406/ 409/410/412/415/413/429（其他请求错误）

------

## *406 Not Acceptable（内容协商失败）

**语义**：客户端的 `Accept` 头声明只接受某些媒体类型/语言，但服务端**没有任何一种能满足**。
 **何时用**：

- 客户端 `Accept: application/xml`，你只提供 `application/json`。
- 客户端 `Accept-Language: fr`，你只支持 `en/zh`（更常见做法是忽略而不是 406）。

**FastAPI**（通常由框架自动选最合适的；强要报 406 可手动抛）：

```
from fastapi import HTTPException
raise HTTPException(status_code=406, detail="not_acceptable")
```

**统一响应**（你没专门码时会落到 2001 兜底）：

- HTTP→biz：可临时映射到 `2001 validation_error`；或新增 `2004 not_acceptable`。
- `data`：可回传支持的类型 `{ "supported": ["application/json"] }`。

**前端**：**改请求的 `Accept`** 或退回默认，不必给复杂提示。

**注意**：返回 `Vary: Accept`，利于缓存正确性。



## 409 Conflict（业务状态冲突）

**什么时候用**

- 邮箱已存在、用户名占用（重复创建）。
- 资源当前状态不允许该操作（例如“已发布”不能编辑）。
- 幂等键重复、订单已处理。
- **版本/乐观锁**冲突（不使用条件请求时）。

**FastAPI怎么抛（业务层建议用 BizError）**

```python
raise BizError(409, CODE_CONFLICT, "email already exists")
# 或更细分：4002 email_exists / 4003 version_conflict / 4004 state_invalid ...
```

**统一响应**

- 409 → `CODE_CONFLICT=4001`（或你扩展的细分码）
- `message`：`"conflict"` / 更具体如 `"email_exists"`
- `data`：可选 `{ "field": "email" }` / `{ "current_state": "published" }`

**前端处理**

- 表单/按钮处给出明确指引（“去登录”、“刷新页”、“重新加载最新版本”）。

**注意**

- 与 412 的区别：**412 Precondition Failed** 通常用于条件请求（`If-Match`/ETag）失败；你没用条件请求时，统一用 409。

---



## 410 Gone（资源永久删除/遗失） 

**语义**：资源**曾经存在**，但**已永久移除**，将来不会再出现（比 404 更肯定）。
 **何时用**：

- 已下线的文章、已撤回的公开链接、一次性下载链接已用过。
- SEO/缓存明确化（告诉客户端“别再找了”）。

**FastAPI**：

```py
raise HTTPException(status_code=410, detail="gone")
```

**统一响应**：

- HTTP→biz：默认会落到 2001；建议新增 `3002 gone`（属于资源类 3xxx）。
- `data`：可给替代资源/跳转建议 `{ "redirect_to": "/..." }`。

**前端**：展示“已删除/已过期”的空态，提供返回入口。

**注意**：与 404 区别：**404 不表态**是否曾存在；**410 明确已永久删除**。

------



## *412 Precondition Failed（条件请求失败 / 乐观锁） 

**语义**：请求中带了**条件**（如 `If-Match` / `If-Unmodified-Since`），服务端校验**不通过**。
 **何时用**：

- **ETag 乐观锁**：客户端带 `If-Match: "<etag>"` 更新资源，服务器发现 etag 不一致 → 412。
- **并发保护**：只在资源未被改动时才允许操作。
- **防止“更新丢失"**

**FastAPI**：

```python
from fastapi import Header, HTTPException

def update_user(..., if_match: str | None = Header(default=None)):
    current_etag = repo.get_etag(user_id)
    if not if_match or if_match != current_etag:
        raise HTTPException(status_code=412, detail="precondition_failed")
```

**统一响应**：

- HTTP→biz：建议映射到 **冲突类**，如 `4003 precondition_failed`（4xxx）。
- `data`：可返最新 etag `{ "current_etag": "..." }` 便于前端刷新重试。

**前端**：遇 412 → **提示“内容已被他人更新”** → 刷新数据/手动合并后再提交；或自动用新 etag 重试（视产品而定）。

**注意**：配合响应头 `ETag: "..."`；若用 `If-None-Match`/`If-Modified-Since` 做缓存，没变时应返回 **304** 而非 412。



------

## *415 Unsupported Media Type（请求体类型不支持）  

**语义**：`Content-Type` 不被服务端支持。
 **何时用**：

- 你的接口只接受 `application/json`，但客户端发了 `text/plain`。
- 上传接口只接受 `multipart/form-data`，客户端却发成了 `application/json`。

**FastAPI**：

```python
raise HTTPException(status_code=415, detail="unsupported_media_type")
```

**统一响应**：

- HTTP→biz：默认会落到 2001；建议新增 `2005 unsupported_media_type`。
- `data`：回传支持的类型 `{ "supported": ["application/json"] }`。

**前端**：**改 `Content-Type`**，或按后端的上传规范重新封装。

**注意**：上传表单需正确 boundary；可返回 `Accept-Patch`/`Accept` 说明支持的类型（可选）。

------



## *413 Payload Too Large（请求体过大）

**语义**：请求体大小超过服务器限制（老名 `Request Entity Too Large`）。
 **何时用**：

- 文件超出上传大小限制（比如 >10MB）。
- JSON 过大、批量数据过多。

**FastAPI**：

- 通常在 **网关/ASGI 服务器**（Nginx/Traefik/Uvicorn）先截断；也可在应用层手动判断：

```python
raise HTTPException(status_code=413, detail="payload_too_large")
```

**统一响应**：

- HTTP→biz：默认会落到 2001；建议新增 `2006 payload_too_large`。
- `data`：给出限制 `{ "max_mb": 10 }`。

**前端**：拦截选择文件时就校验大小；给出“压缩/拆分/改为异步导入”的方案。

**注意**：可配合 `Content-Length`/`Max-Content-Length`（网关配置），并返回 `Retry-After`（如果是临时限制）。

------



## 429 Too Many Requests（限流）（会用到）

**语义**：**触发速率限制**（IP、用户、接口、登录尝试等）。
 **何时用**：

- 登录错误次数过多、接口 QPS 超标、爬虫/突发流量控制。

**FastAPI**：

- 用限流中间件（如 SlowAPI/Redis）或自写：

```python
raise HTTPException(
    status_code=429,
    detail="rate_limited",
    headers={"Retry-After": "15"}  # 15 秒后再试
)
```

**统一响应**：

- HTTP→biz：你已设置 `429 → 8001 rate_limited`（👌）。
- `data`：可回 `retry_after`（秒）与剩余额度（若有） `{ "retry_after": 15 }`。

**前端**：**禁用按钮/倒计时**，到期再允许重试；避免自动狂刷。

**注意**：可同时返回 `X-RateLimit-Limit/Remaining/Reset` 等头（若你做配额体系）。

---

### 整理：

| HTTP    | 语义                   | 何时用                                 | 前端动作（要点）               |
| ------- | ---------------------- | -------------------------------------- | ------------------------------ |
| **406** | 内容协商失败           | `Accept` 不匹配                        | 调整 `Accept`                  |
| **410** | 永久删除               | 资源曾存在、现永久移除                 | 空态/返回/替代链接             |
| **412** | 条件请求失败（乐观锁） | `If-Match` 等条件不满足（ETag 不一致） | 刷新数据/提示被他人更新/再提交 |
| **415** | 媒体类型不支持         | `Content-Type` 不被支持                | 改 `Content-Type`/按规范上传   |
| **413** | 请求体过大             | 上传/JSON/批量超限制                   | 前置校验/压缩/拆分             |
| **429** | 频率限制               | 登录过多/接口超频                      | 按 `Retry-After` 倒计时重试    |

> 一贯的总原则：**HTTP 定大类动作，code 定细因；字段级错误只走 422（`data.errors` 渲染表单）；敏感/技术细节只进日志，响应里给 `request_id` 便于排错。**









# 九、全局异常处理器 & 统一响应格式【略读】

------

## 0. 目标与原则

- **一个响应壳**：无论成功/失败，格式固定为
   `code（业务码）/ message（稳定短标签）/ data（负载）/ request_id（追踪）`。
- **四类异常全接住**：
   ① 自定义业务异常（BizError）
   ② HTTP 异常（HTTPException）
   ③ 字段校验异常（RequestValidationError）
   ④ 其他未知异常（统一按 500）。
- **分层表达**：**HTTP 定大类动作**（认证、权限、存在、限流…），**code 定细因**（邮箱已存在、版本冲突…）。
- **最小暴露**：对外不泄漏堆栈/SQL/内部细节；这些只进日志，通过 `request_id` 追踪。
- **前端契约可预期**：字段级错误→`data.errors`；全局/非字段错误→前端用 `code` 映射文案与交互。

------

## 1. 生命周期与链路

1. **请求进入**
   - 中间件生成/透传 `request_id`，写入 `request.state.request_id`，并计时。
2. **路由/依赖/业务执行**
   - 可能抛出 4 类异常之一（见下一节）。
3. **全局异常处理**
   - 匹配到对应的 handler，**统一转为标准响应壳**；同时打结构化日志（含 `request_id`）。
4. **响应返回**
   - 失败：HTTP 状态码 + 业务码 + 标签 + `data`（按规则）+ `request_id`。
   - 成功：`code=0`；304/3xx 等按 HTTP 规范处理（304 无响应体，不包壳）。

------

## 2. 统一处理的“四类异常”与边界

### 2.1 业务异常（你主动抛）

- **何时**：领域规则失败（邮箱已存在、状态不允许、额度不足、版本冲突…）。
- **你指定**：`http_status + code（业务码） + message（短标签） + data（可选上下文）`。
- **响应**：按你给的值直接封装为统一响应（无需再映射）。
- **好处**：业务语义**完全可控**、前后端**可精细交互**。

### 2.2 HTTP 异常（协议/资源层）

- **何时**：未认证(401)、无权限(403)、不存在(404)、限流(429)、方法不被允许(405)…
- **抛法**：`HTTPException(status_code=..., detail=...)`（框架/你都可能抛）。
- **处理**：读取 `status_code`，**映射**到默认业务码（如 401→1001、404→3001…）。
  - `detail` 是**安全的字符串**时，可作为 `message`；否则使用**固定标签**（如 `"http_error"`），必要时把结构化 `detail` 放到 `data.detail`。
- **前端**：优先依据 **HTTP** 做全局动作（跳登录/无权页/空态/倒计时）。

### 2.3 字段校验异常（入参不合法）

- **何时**：Pydantic/FastAPI 自动校验失败（必填、类型、格式、范围、枚举…）。
- **抛法**：框架**自动**抛 `RequestValidationError`（别手动抛 422）。
- **处理**：固定
  - `http_status=422`
  - `code=2001（validation_error）`
  - `message="validation_error"`
  - `data.errors = exc.errors()`（或你在这里做一次“字段→友好文案”的映射）。
- **前端**：**按 `data.errors` 逐字段渲染表单错误**，无需 toast。

### 2.4 其他未知异常（兜底）

- **何时**：代码 bug、不可预期错误、第三方异常未翻译等。
- **处理**：
  - `http_status=500`
  - `code=9001（internal_error）`
  - `message="internal_error"`
  - `data=null`（不透内部细节）
  - 日志打堆栈 + `request_id`。
- **前端**：统一“系统繁忙”，保留 `request_id` 供报障。

> 补充：对数据库唯一约束、下游超时/JWT 无效等“技术异常”，**建议在靠近源头的业务/仓储层翻译**成 BizError/HTTPException 再抛，这样全局处理器收到的已是“语义化”的异常。

------

## 3. 统一响应壳的字段语义

- **code（整数）**：**业务码主键**。分段建议
   `0 成功 / 1xxx 鉴权 / 2xxx 请求与校验 / 3xxx 资源 / 4xxx 冲突与状态 / 5xxx 外部依赖 / 8xxx 流控 / 9xxx 系统`。
   最小可用集：`0, 1001, 1002, 2001, 3001, 4001, 8001, 9001`；按需扩展子码（如 4002 email_exists、5003 upstream_timeout）。
- **message（短标签）**：与 `code` **默认一一对应**的稳定标签（如 `"ok"`, `"validation_error"`, `"conflict"`）。
   作用：日志分组、兜底显示（非直面用户的句子）。如需更具体可在局部覆盖，但保持**无敏感信息**。
- **data**：
  - 422：`data.errors=[{field,msg,...}]`（**给用户看**）
  - 429/503：可加 `retry_after`
  - 409/412：可加 `field/current_state/current_etag` 等
  - 其它按需，但**慎放内部细节**
- **request_id**：贯穿请求与日志；前端错误提示可附带，便于排错。

------

## 4. HTTP ↔ 业务码：映射策略

- **默认映射（HTTP→code）**：用于处理 `HTTPException`、框架抛出的错误。示例：
   `401→1001、403→1002、404→3001、409→4001、422→2001、429→8001；5xx→9001；其他 4xx→2001`。
   可按需补：`415→2005、413→2006、406→2004、410→3002、412→4003` 等。
- **业务显式指定**：抛 BizError 时**直接给出** `http_status + code`，无需查表。
- **不要追求一一对应**：一个 HTTP 下可以有多个业务码（例如 409 下细分邮箱已存在/版本冲突/状态非法…）。
   **前端流程**：先看 HTTP 做**全局动作**，再看 `code` 做**精细交互与文案**。

------

## 5. 日志与可观测

- **统一结构化日志**（错误时必打）：
   `timestamp, level, request_id, path, method, http_status, code, message, latency_ms, client_ip, user_agent, extra...`
- **分级**：
  - 业务/校验类用 **warning**
  - 未知异常/5xx 用 **error/exception**（含堆栈）
- **304/3xx 也记录**：便于观察缓存命中率、重定向链路。
- **监控维度**：按 `http_status` 和 `code` 聚合，SLA/告警可区分 4xx vs 5xx、热点 code。

------

## 6. 前端协作“机读规则”

1. **全局动作优先**（按 HTTP）：
    `401` 登录/刷新 → `403` 无权 → `429` 冷却（读 `Retry-After`）→ `404` 空态。
2. **字段级**：`code==2001` 且 `data.errors` 存在 → 表单逐字段渲染。
3. **其余**：用 `code → 文案表（i18n）` 显示用户友好提示；`message` 仅兜底/开发态。
4. **错误反馈**：展示 `request_id` 供用户/客服报障。

------

## 7. 安全与合规

- 不在响应体泄漏堆栈、SQL、内部变量；仅日志记录。
- 对 `HTTPException.detail` 做**白名单透出**（字符串可直用、结构化放 `data.detail`、敏感则替换为稳定标签）。
- 生产与开发可区分开关（开发可附加 debug 片段，生产关闭）。

------

## 8. 版本演进与协作流程

- **新增业务码**：遵循分段，**一码一义**；文档补齐“HTTP/含义/前端动作/示例”。
- **契约测试**：覆盖关键失败分支（特别是 401/403/404/409/422/429/5xx）。
- **回滚友好**：扩展优先新增 code，不破坏旧语义。
- **知识同步**：接口文档模板固定展示：HTTP + code + message + data 示例。

------

## 9. 小抄：典型场景该怎么定

- **未登录/过期**：`401 + 1001 unauthenticated`（前端跳登录/刷新）。
- **无权限**：`403 + 1002 forbidden`（无权页/引导申请）。
- **不存在**：`404 + 3001 not_found`（空态）。
- **字段错**：`422 + 2001 validation_error`（`data.errors`）。
- **限流**：`429 + 8001 rate_limited`（倒计时重试）。
- **冲突**：`409 + 4001 conflict`（或细分 `4002 email_exists / 4003 version_conflict`…）。
- **未知错**：`500 + 9001 internal_error`（不透细节，附 `request_id`）。

------

> **一句话压轴**：
>  让框架和业务“随便抛”，但**所有路都通向统一响应壳**；
>  **HTTP 负责“做什么动作”，code 负责“为什么失败”**；
>  字段错走 `data.errors`，机密只进日志，`request_id` 贯穿全链路。





# 10. 业务码（code）规范与对照表示例

> 统一响应壳：`{ code, message, data, request_id }`
>  设计原则：**HTTP 定大类动作**（认证/权限/存在/限流…），**code 定细因**（邮箱已存在、版本冲突…）。
>  `message` 为**稳定短标签**（非直给用户的长句）；**用户可见文案**由前端基于 `code`（或 `data.errors`）做 i18n 映射。

------

## 一、分段规范

- `0`：成功
- `1xxx`：鉴权/认证
- `2xxx`：请求/协议/校验
- `3xxx`：资源/存在性
- `4xxx`：业务冲突/状态非法
- `5xxx`：外部依赖/下游
- `8xxx`：流控/配额
- `9xxx`：系统/未知

> **一码一义**：发布后不复用、不改语义；遇到新场景再新增 code。

------

## 二、HTTP → code（最小可用集 + 常用扩展）

> 说明：框架抛 `HTTPException` 时走**默认映射**；业务抛 `BizError(http_status, code)` 时**以显式为准**。

| HTTP            | code  | message                | 含义（简）                     | 前端动作（建议）          |
| --------------- | ----- | ---------------------- | ------------------------------ | ------------------------- |
| 200/201/202/204 | 0     | **ok**                 | 成功（创建/异步/无体见 HTTP）  | 正常流程                  |
| 400             | 2002⭐ | **malformed_json**     | JSON 语法错误 / 体解析失败     | 友好提示                  |
| 400             | 2003⭐ | **invalid_request**    | 请求语义错误（非字段级）       | 友好提示                  |
| 401             | 1001  | **unauthenticated**    | 未认证 / 凭证缺失              | 跳登录/刷新               |
| 401             | 1003⭐ | **token_expired**      | 凭证过期                       | 静默刷新/重登             |
| 401             | 1004⭐ | token_invalid          | 凭证无效/签名错误              | 重登                      |
| 403             | 1002  | forbidden              | 已认证但无权限                 | 无权页                    |
| 404             | 3001  | not_found              | 路由/资源不存在                | 空态/返回                 |
| 405             | 2008⭐ | method_not_allowed     | 方法不允许                     | 友好提示                  |
| 406             | 2004⭐ | not_acceptable         | `Accept` 不匹配                | 调整请求                  |
| 410             | 3002⭐ | gone                   | 资源曾存在、现已永久移除       | 空态/替代                 |
| 412             | 4003⭐ | precondition_failed    | 条件请求/ETag 不匹配（乐观锁） | 刷新/重试                 |
| 413             | 2006⭐ | payload_too_large      | 请求体过大                     | 限制/压缩                 |
| 415             | 2005⭐ | unsupported_media_type | `Content-Type` 不支持          | 调整请求                  |
| 409             | 4001  | conflict               | 业务冲突（通用）               | 指引修正                  |
| 409             | 4002⭐ | email_exists           | 邮箱已存在                     | 去登录/改邮箱             |
| 409             | 4004⭐ | version_conflict       | 版本冲突（非条件请求）         | 刷新后再改                |
| 409             | 4005⭐ | state_invalid          | 当前状态不允许该操作           | 指引流程                  |
| 422             | 2001  | validation_error       | **字段级**校验失败             | 按 `data.errors` 渲染表单 |
| 429             | 8001  | rate_limited           | 触发限流                       | 倒计时/禁用               |
| 500             | 9001  | internal_error         | 未知/内部错误                  | 统一兜底                  |
| 502             | 5001⭐ | upstream_error         | 下游错误                       | 可重试/降级               |
| 503             | 5002⭐ | service_unavailable    | 服务不可用/维护/过载           | 倒计时/告知               |
| 504             | 5003⭐ | upstream_timeout       | 下游超时/网关超时              | 重试/降级                 |

> 字段级错误**仅**走 422（`2001`），并返回 `data.errors=[{field,msg}]`。
>  401 建议返回 `WWW-Authenticate: Bearer`；429/503 可带 `Retry-After`。